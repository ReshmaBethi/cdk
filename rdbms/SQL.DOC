{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\adjustright \fs20 \snext0 Normal;}{
\s1\qj\keepn\nowidctlpar\adjustright \f1 \sbasedon0 \snext0 heading 1;}{\s2\sb240\sa60\keepn\nowidctlpar\adjustright \b\i\f1 \sbasedon0 \snext0 heading 2;}{\s3\sb240\sa60\keepn\nowidctlpar\adjustright \b \sbasedon0 \snext0 heading 3;}{
\s4\qj\keepn\nowidctlpar\adjustright \b\f1 \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 \sbasedon0 \snext15 header;}{\s16\nowidctlpar
\tx1620\tx2970\tx4500\tx6210\tx7560\adjustright \f1 \sbasedon0 \snext16 q1;}{\s17\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 \sbasedon0 \snext17 footer;}{\*\cs18 \additive \sbasedon10 page number;}{\s19\qj\nowidctlpar\adjustright \f1 
\sbasedon0 \snext19 Body Text;}{\s20\nowidctlpar\adjustright \fs20 \sbasedon0 \snext20 footnote text;}{\*\cs21 \additive \super \sbasedon10 footnote reference;}}{\*\listtable{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}{\list\listtemplateid-1851782898{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}
\b\fbias0 \fi-525\li525\jclisttab\tx525 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat3\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\b\fbias0 \fi-525\li525\jclisttab\tx525 }{\listlevel\levelnfc0\leveljc0
\levelfollow0\levelstartat3\levelspace0\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\b\fbias0 \fi-720\li720\jclisttab\tx720 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\b\fbias0 \fi-1080\li1080\jclisttab\tx1080 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers
\'01\'03\'05\'07\'09;}\b\fbias0 \fi-1080\li1080\jclisttab\tx1080 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\b\fbias0 
\fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\b\fbias0 \fi-1440\li1440\jclisttab\tx1440 }
{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\b\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listlevel\levelnfc0
\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\b\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listname ;}\listid12656656}
{\list\listtemplateid-2043742554{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat3
\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers
\'01\'03\'05;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }
{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listname ;}\listid106704072}{\list\listtemplateid-327276982\listsimple{\listlevel\levelnfc0\leveljc0
\levelfollow0\levelstartat1\levelold\levelspace0\levelindent283{\leveltext\'02\'00\u-4050 ?;}{\levelnumbers\'01;}\fi-283\li283 }{\listname ;}\listid377243378}{\list\listtemplateid1131689596\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\b\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid404257427}{\list\listtemplateid2124978810{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat4\levelspace0
\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat2\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\fbias0 \fi-1440\li1440
\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers
\'01\'03\'05\'07\'09\'0b;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\fbias0 
\fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\fbias0 \fi-1800\li1800
\jclisttab\tx1800 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\fbias0 \fi-1800\li1800\jclisttab\tx1800 
}{\listname ;}\listid1049691260}{\list\listtemplateid-1939588378{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'01\'00;}{\levelnumbers\'01;}\fi-720\li720 }{\listlevel\levelnfc0\leveljc0
\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\fi-720\li1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\fi-720\li2160 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\fi-720\li2880 }{\listlevel
\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\fi-720\li3600 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0
\levelindent720{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\fi-720\li4320 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\fi-720\li5040 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\fi-720\li5760 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\fi-720\li6480 }{\listname ;}\listid1608613457}{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1723753238}{\list\listtemplateid-60389416{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\'01\'00;}{\levelnumbers\'01;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\fbias0 \fi-1440\li1440
\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers
\'01\'03\'05\'07\'09\'0b;}\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\fbias0 
\fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\fbias0 \fi-1800\li1800
\jclisttab\tx1800 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\fbias0 \fi-1800\li1800\jclisttab\tx1800 
}{\listname ;}\listid1753165135}{\list\listtemplateid541643058{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\b\fbias0 \fi-360\li360\jclisttab\tx360 }{\listlevel\levelnfc0
\leveljc0\levelfollow0\levelstartat2\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\b\fbias0 \fi-360\li360\jclisttab\tx360 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\b\fbias0 \fi-720\li720\jclisttab\tx720 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\b\fbias0 
\fi-1080\li1080\jclisttab\tx1080 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\b\fbias0 \fi-1080\li1080\jclisttab\tx1080 }{\listlevel
\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\b\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\b\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\b\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\b\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listname ;}\listid1843814069}{\list\listtemplateid-980907436\listsimple{\listlevel\levelnfc0\leveljc0
\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'02\'00\u-4050 ?;}{\levelnumbers\'01;}\fi-360\li360 }{\listname ;}\listid2069455837}}{\*\listoverridetable{\listoverride\listid1608613457\listoverridecount0\ls1}
{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent432{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-432\li792 }}\ls2}
{\listoverride\listid2069455837\listoverridecount0\ls3}{\listoverride\listid377243378\listoverridecount0\ls4}{\listoverride\listid1049691260\listoverridecount0\ls5}{\listoverride\listid1843814069\listoverridecount0\ls6}{\listoverride\listid106704072
\listoverridecount0\ls7}{\listoverride\listid12656656\listoverridecount0\ls8}{\listoverride\listid1753165135\listoverridecount0\ls9}{\listoverride\listid1723753238\listoverridecount0\ls10}{\listoverride\listid404257427\listoverridecount0\ls11}}{\info
{\title INTRODUCTION TO STRUCTURED QUERY LANGUAGE}{\author fands}{\operator FANDS}{\creatim\yr1998\mo9\dy20\hr17\min34}{\revtim\yr1998\mo10\dy12\hr15\min15}{\printim\yr1998\mo10\dy12\hr15\min4}{\version12}{\edmins115}{\nofpages21}{\nofwords5205}
{\nofchars29674}{\*\company FANDS}{\nofcharsws0}{\vern71}}\paperw11909\paperh16834 \widowctrl\ftnbj\aenddoc\hyphcaps0\formshade\viewkind1\viewscale75 \fet0\sectd \psz9\linex0\headery706\footery706\colsx709\endnhere\sectdefaultcl {\header \pard\plain 
\s15\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 {\b FANDS INFOSYS\tab \tab }{\field{\*\fldinst {\cs18  PAGE }}{\fldrslt {\cs18\lang1024 21}}}{\cs18 \tab }{\b 
\par }}{\footer \pard\plain \s17\qr\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 {
\par }}{\*\pnseclvl1\pndec\pnprev1\pnstart1\pnindent720\pnhang}{\*\pnseclvl2\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl3\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl4\pndec\pnprev1\pnstart1\pnindent720\pnhang
{\pntxtb .}}{\*\pnseclvl5\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl6\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl7\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl8
\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}{\*\pnseclvl9\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxtb .}}\pard\plain \nowidctlpar\box\brdrs\brdrw15\brsp20 \adjustright \fs20 {\b\caps\f1\fs24 CHAPTER I \tab 
        Introduction to Structured Query Language}{\b\caps\f1\fs28 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par {\listtext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 1.1\tab}}\pard \qj\fi-1440\li1440\nowidctlpar\jclisttab\tx1440\ls9\ilvl1\adjustright {\b\f1\fs24 Normalization
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }\pard \qj\nowidctlpar\ilvl12\adjustright {\f1\fs24 
SQL allows users to access data in relational database management systems, such as Oracle, Sybase, Informix, Microsoft SQL Server, Access and others by allowing users to describe the data the user wishes to see. SQL also allows users to define the data in
 a database and manipulate that data.
\par DBMS's store data in files declared by system managers before new tables are created (on large systems), but the system stores the data in a special format and may spread data from one table over several files. In the d
atabase world, a set of files created for a database is called a }{\f1\fs24\ul tablespace}{\f1\fs24 . In general, on small systems, everything about a database (definitions and all table data) is kept in one file. 
\par }{\b\f1\fs24 Normalization }{\f1\fs24 is a technique of database design that suggests that certain criteria be used when constructing a table layout (deciding what columns each table will have and creating the key structure), where the idea is to }{
\b\f1\fs24 eliminate redundancy}{\f1\fs24  of non-key data across tables. Normalization is usually referred to in terms o
f forms and I will introduce only the first three, even though it is somewhat common to use other, more advanced forms (fourth, fifth etc.). 
\par }\pard \qj\fi360\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par {\pntext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-432\li792\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent432\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b\f1\fs24 First Normal Form}{\f1\fs24 
 refers to moving data into separate tables where the data in each table is of a similar type and by giving each table a primary key. 
\par {\pntext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-432\li792\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent432\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b\f1\fs24 Second Normal Form}{\f1\fs24 
 involves taking out data off to other tables that is only dependent of a part of the key.
\par {\pntext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-432\li792\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent432\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b\f1\fs24 Third Normal Form}{\f1\fs24 
 involves getting rid of anything in the tables that doesn't depend solely on the 
primary key. Only include information that is dependent on the key and move off data to other tables that are independent of the primary key and create a primary keys for the new tables. 
\par }\pard \qj\fi360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {\f1\fs24 
\par }\pard \qj\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\b\f1\fs24 1.2\tab \tab SQL}{\f1\fs24 
\par }\pard \qj\fi360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {\f1\fs24 
\par There are two basic types in SQL : 
\par {\pntext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-432\li1512\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent432\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b\f1\fs24 DDL}{\f1\fs24  (Data Definiti
on Language) refers to the Create Table statement.
\par {\pntext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-432\li1512\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent432\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b\f1\fs24 DML}{\f1\fs24 
 (Data Manipulation Language) refers to the Select, Update, Insert and Delete statements.
\par }\pard \qj\fi360\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 1.2.1\tab \tab Queries}{\f1\fs24 
\par }\pard \qj\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par A }{\b\f1\fs24 single-row query}{\f1\fs24  is a query that returns one row as its result and }{\b\f1\fs24 a multiple-row query}{\f1\fs24 
 is a query that returns more than one row as its result. Whether a query returns one row or more than one row is entirely dependent on the design (or schema) of the tables of the database. As query-writer, you must be aware of the schema, be sure to incl
u
de enough conditions and structure your SQL statement properly, so that you will get the desired result (either one row or multiple rows). E.g., if you wanted to be sure that a query of the Supplier table returned only one row, consider an equal condition
 of the primary key-column (Supp_no).
\par }\pard \qj\fi360\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par }\pard \qj\li360\nowidctlpar\ilvl12\adjustright {\f1\fs24 Three reasons immediately come to mind as to why this is important. 
\par First, getting multiple rows when you were expecting only one, or vice-versa, may mean that the query is erroneous, that the database is incomplete, or simply, you learned something new about your data. 
\par If you are using an update or delete statement, you had better be sure that the statement that you write performs the operation on the desired row (or rows)...or else, you might be deleting or updating more rows than you intend. 
\par Any queries written in Embedded SQL must be carefully thought out as to the number of rows returned. If you write a single-row query, only one SQL statement may need to be performed to complete the programming logic required. I
f your query, on the other hand, returns multiple rows, you will have to use the Fetch statement and quite probably, some sort of looping structure in your program will be required to iterate processing on each returned row of the query. 
\par 
\par Another design q
uestion...the term "relationships" usually refers to the relationships among primary and foreign keys between tables. This concept is important because when the tables of a relational database are designed, these relationships must be defined because they
 determine which columns are or are not primary or foreign keys. 
\par 
\par {\listtext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 1.3\tab}}\pard \qj\fi-1440\li1440\nowidctlpar\jclisttab\tx1440\ls7\ilvl1\adjustright {\b\f1\fs24 Relationships
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 
\par 1.3.1\tab \tab One to One Relationship (\ldblquote 1 ..1\rdblquote )
\par }\pard \qj\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par A One-to-One Relationship means that you have a primary key column that is related to a foreign key column and that for every pri
mary key value, there is one foreign key value. E.g., in the first example, the EmpAdd , we add an EmpIDNo column. Then, the EmpAdd  is related to the EmpStat Table (second example table) by means of that EmpIDNo. Specifically, each employee in the EmpAdd
  has statistics (one row of data) in the EmpStat Table. Even though this is a contrived example, this is a "1-1" relationship. 
\par The other two kinds of relationships may or may not use logical primary key and foreign key constraints.
\par  
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 1.3.2\tab \tab One to Many Relationship (\ldblquote 1 .. M\rdblquote )
\par }\pard \qj\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par This means that for every column value in one table, there is one or more related values in another table. Key constraints may be added to the design, or possibly just the use of some sort of identifier column may be used to establis
h the relationship. An example would be that for every Supp_no in the Supplier table, there are one or more (zero is permissible too) Items bought in the Item table.
\par 
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 1.3.3\tab \tab Many to Many Relationship (\ldblquote M .. M\rdblquote )}{\f1\fs24 
\par }\pard \qj\nowidctlpar\ilvl12\adjustright {\f1\fs24 
\par This relationship does not involve keys generally and usually involves identifying columns. The unusual occurence of a "M-M" means that one column in one table is related to another column in another table and for every value of one of these two columns, 
there are one or more related values in the corresponding column in the other table (and vice-versa), or more a common possibility, two tables have a 1-M relationship to each other (two relationships, one 1-M going each way).
\par  
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 1.4\tab \tab Simple Select Statement}{\f1\fs24 
\par 
\par In a relational database, data is stored in tables. An example table would relate Social Security Number, Name and Address: 
\par 
\par EmpAdd  Table :
\par 
\par }\pard \qj\nowidctlpar\tx1620\tx2970\tx4500\tx6210\tx7560\adjustright {\f1\fs24 SSN\tab FirstName\tab LastName \tab Address\tab City\tab State 
\par 
\par 512687458\tab Joe\tab Smith \tab 83 First Street\tab Howard\tab Ohio 
\par 758420012\tab Mary\tab Scott \tab 842 Vine Ave.\tab Losantiville\tab Ohio 
\par 102254896\tab Sam\tab Jones\tab 33 Elm St.\tab Paris\tab New York 
\par 876512563\tab Sarah\tab Ackerman\tab 440 U.S. 110\tab Upton\tab Michigan 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par Now, let's say you want to see the address of each employee. 
\par 
\par SELECT FirstName, LastName, Address, City, State 
\par FROM EmpAdd ; }{\cs21\f1\fs24\super *{\footnote \pard\plain \s20\nowidctlpar\adjustright \fs20 {\cs21\super *}{ As a style we will write all keywords in SQL statements capitalized.}}}{\f1\fs24 
\par 
\par The following is the results of your query of the database: 
\par 
\par }\pard\plain \s16\qj\nowidctlpar\tx1440\tx2970\tx5040\tx6480\adjustright \f1 {First Name\tab Last Name \tab Address\tab City\tab State
\par 
\par Joe\tab Smith\tab 83 First Street \tab Howard\tab Ohio
\par Mary\tab Scott\tab 842 Vine Ave\tab Losantiville\tab Ohio
\par Sam\tab Jones\tab 33 Elm St. \tab Paris\tab New York
\par Sarah\tab Ackerman\tab 440 U.S. 110 \tab Upton\tab Michigan
\par }\pard\plain \qj\nowidctlpar\adjustright \fs20 {\f1\fs24 
\par To explain what you just did, you asked for the all of data in the EmpAdd  and specifically, you asked for the columns called FirstName, LastName, Address, 
City and State. Note that column names and table names do not have spaces. They must be typed as one word; and that the statement ends with a semicolon (;). The general form for a SELECT statement, retrieving all of the rows in the table is: 
\par 
\par SELECT ColumnName, ColumnName, ... 
\par FROM TableName; 
\par 
\par To get all columns of a table without typing all column names, use: 
\par 
\par SELECT * FROM Tablename; 
\par 
\par Each database management system (DBMS) and database software has different methods for logging in to the database and entering SQL commands.
\par 
\par }{\b\f1\fs28 1.4.1 \tab \tab Conditional Selection 
\par }{\f1\fs24 
\par The WHERE clause is used only when certain rows of the table are to be displayed, based on the criteria described in that WHERE clause.
\par 
\par Let's look at a new example table of Employee Status: 
\par 
\par EmpStat Table
\par 
\par }\pard \qj\nowidctlpar\tx2160\tx4140\tx5760\adjustright {\f1\fs24 EmpIDNo\tab Salary\tab Benefits\tab \tab Position 
\par 
\par 010\tab 75000\tab 15000\tab  \tab Manager
\par 105\tab 65000\tab 15000 \tab \tab Manager
\par 152\tab 60000\tab 15000\tab \tab Manager
\par 215\tab 60000\tab 12500 \tab \tab Manager
\par 244\tab 50000\tab 12000 \tab \tab Staff
\par 300\tab 45000\tab 10000\tab  \tab Staff
\par 335\tab 40000\tab 10000\tab  \tab Staff
\par 400\tab 32000\tab 7500 \tab \tab Entry-Level
\par 441\tab 28000\tab 7500\tab \tab Entry-Level
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par If you want to display all the detail information of the Managers then, we can add a condition using  a 'where'  clause in the previous query. 
\par 
\par SELECT *
\par FROM empstat
\par WHERE empidno = 152 ;
\par 
\par To check the condition, we can use the various Relational Operators which are as follows :
\par 
\par }{\b\f1\fs28 1.4.2\tab \tab Relational Operators 
\par }{\f1\fs24\ul 
\par }\pard \qj\nowidctlpar\tx1890\adjustright {\f1\fs24 = \tab Equal
\par <> or != \tab Not Equal
\par <\tab Less Than
\par >\tab Greater Than
\par <=\tab Less Than or Equal To
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 >=\tab \tab        Greater Than or Equal To
\par 
\par If you wanted to see the EMPIDNO's of those earning more than  50,000, use the following:
\par 
\par SELECT  empidno
\par FROM  empstat
\par WHERE salary >= 50000;
\par 
\par Notice that the >= (greater than or equal to) sign is used, as we wanted to see those who earned greater than 50,000 or equal to 50,000 listed together. This displays :
\par 
\par EMPIDNO
\par ------------
\par 010
\par 105
\par 152
\par 215
\par 244
\par 
\par The WHERE description, SALARY >= 50000 is known as a condition. The same can be done for text columns:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE position = 'Manager';
\par 
\par This displays the ID Numbers of all Managers. Generally, with text columns, make sure that any text that appears in the statement is surrounded by single quotes (').
\par 
\par }{\b\f1\fs28 1.4.3\tab \tab Compound Conditions
\par }{\f1\fs24 
\par We can combine multiple conditions using }{\b\f1\fs24 'Logical Operators'}{\f1\fs24  : }{\b\f1\fs24 AND}{\f1\fs24   and }{\b\f1\fs24 OR}{\f1\fs24 .
\par }{\b\f1\fs24 
\par }{\f1\fs24 The AND operator joins two or more conditions and displays a row only if that row's data satisfies ALL conditions listed (i.e. all conditions hold true). E.g., to display all staff earning over 40,000, use:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE salary > 40000 AND position = 'Staff';
\par 
\par The OR operator joins two or more conditions, but returns a row if ANY of the conditions listed hold true. To see all those who make less than 40,000 or have less than 10,000 in benefits listed together, use the following query:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE salary < 40000 OR}{\b\f1\fs24  }{\f1\fs24 benefits < 10000;
\par 
\par AND & OR can be combined e.g.
\par 
\par select empidno
\par from empstat
\par where position = 'Manager' }{\b\f1\fs24 and}{\f1\fs24  salary > 60000 }{\b\f1\fs24 or}{\f1\fs24  benefits > 12000;
\par 
\par First SQL finds the rows where the salary is greater than 60,000 and the position column is equal to Manager, then taking this new list of rows, SQL then sees if any of these rows satisfies the previous AND\~
condition or the condition that the Benefits column is greater then 12,000. Subsequently, SQL only displays this second new list of rows, keeping in mind that anyone with Benefits over 12,000 will be included as the OR\~
operator includes a row if either resulting condition is True. }{\i\f1\fs24 Also note that the AND\~operation is done first}{\f1\fs24 .
\par 
\par To generalize this process, SQL performs the AND\~operation(s) to determine the rows where the AND operation(s) hold true (remember: all of the conditions are true), then these results are used to compare with the OR\~
conditions and only display those remaining rows where the conditions joined by the OR\~operator hold true.
\par 
\par To perform OR's before AND's, like if you wanted to see a list of employees making a large salary (>50,000) or have a large benefit package (>10,000) and that happen to be a manager, use parentheses:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE position = 'Manager' and\~(salary > 50000 or benefit > 10000);
\par 
\par }{\b\f1\fs28 1.4.4\tab \tab IN & BETWEEN
\par }{\f1\fs24 
\par Suppose we want a list of employees working as Manager or Clerk, the query would be 
\par SELECT empidno FROM empstat
\par WHERE poisition = \lquote Manager\rquote  OR position = \lquote Clerk\rquote ;
\par  
\par To simplify such compound conditions we can use operator \lquote in\rquote .
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE position IN ('Manager', \lquote Clerk\rquote );
\par 
\par or to list those making greater than or equal to 30,000, but less than or equal to 50,000, use:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE salary BETWEEN 30000 AND 50000;
\par 
\par To list everyone not in this range, try:
\par 
\par SELECT empidno
\par FROM empstat
\par WHERE salary NOT BETWEEN 30000 AND 50000;
\par 
\par Similarly, NOT\~IN lists all rows excluded from the IN list.
\par 
\par }{\b\f1\fs28 1.4.5\tab \tab Using LIKE
\par }{\f1\fs24 
\par Look at the EmpStat Table and say you wanted to see all people whose last names started with "L"; try:
\par 
\par SELECT empidno
\par FROM empadd 
\par WHERE lastname}{\b\f1\fs24 \~}{\f1\fs24 LIKE\~'L%';
\par 
\par The percent sign (%) is used to represent any possible character (number, letter, or punctuation) or set of characters that might appear after the "L". To find those people with LastName's ending in "L", use '%L', or if you wanted the "L" in the middle of
 the word, try '%L%'. The '%' can be used for any characters, in that relative position to the given characters. }{\b\f1\fs24 NOT\~LIKE}{\f1\fs24  displays rows not fitting the given description.
\par 
\par }{\b\f1\fs28 1.4.6\tab \tab DISTINCT and Eliminating Duplicates
\par }{\f1\fs24 
\par Let's say that you want to list the ID an
d names of only those people who have sold an antique. Obviously, you want a list where each seller is only listed once--you don't want to know how many Item a person sold, just the fact that this person sold one. This means that you will need to tell SQL
 to eliminate duplicate sales rows and just list each person only once. To do this, use the }{\i\f1\fs24 DISTINCT}{\f1\fs24  keyword.
\par 
\par First, we will need an equijoin to the Supplier table to get the detail data of the person's Lname and Fname. However, keep in mind that since the
 Cust_no column in the Item table is a foreign key to the Supplier table, a seller will only be listed if there is a row in the Supplier table listing the ID and names. We also want to eliminate multiple occurences of the Cust_no in our listing, so we use
 DISTINCT on the column where the repeats may occur.
\par 
\par }{\b\f1\fs28 1.5\tab \tab Order By Clause
\par }{\f1\fs24 
\par If we want the list alphabetized by position . Then, we will use the ORDER BY clause:
\par 
\par SELECT *
\par FROM empstat
\par ORDER BY position;
\par 
\par }{\b\f1\fs28 1.6\tab \tab GROUP BY & HAVING CLAUSE
\par }{\f1\fs24 
\par One special use of GROUP\~BY is to associate an aggregate function (especially COUNT; counting the number of rows in each group) with groups of rows. 
\par First, assume that the Item table has the Price column and each row has a value for that column. We want to see the price of th
e most expensive item bought by each owner. We have to tell SQL to group each owner's purchases and tell us the maximum purchase price:
\par 
\par SELECT cust_no, max(price)
\par FROM Item
\par GROUP BY cust_no;
\par 
\par Now, say we only want to see the maximum purchase price if the purchase is over 1000, so we use the HAVING clause:
\par 
\par SELECT cust_no, max(price)
\par FROM Item
\par GROUP BY cust_no
\par HAVING price > 1000;
\par 
\par }{\b\f1\fs28 1.7\tab \tab JOINS
\par }{\f1\fs24 
\par In this section, we will only discuss inner joins and equijoins, as in general, they are the most useful.
\par 
\par Good database design suggests that each table lists data only about a single entity and detailed information can be obtained in a relational database, by using additional tables and by using a join.
\par 
\par First, take a look at these example tables:
\par 
\par }\pard\plain \s4\qj\keepn\nowidctlpar\outlinelevel3\adjustright \b\f1 {Supplier
\par }\pard\plain \qj\nowidctlpar\adjustright \fs20 {\f1\fs24 
\par }\pard \qj\fi-1440\li1440\nowidctlpar\adjustright {\f1\fs24 Supp_no\tab Lname \tab \tab Fname
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 01\tab \tab Jones\tab \tab \tab Bill
\par 02\tab \tab Smith\tab \tab \tab Bob
\par 03\tab \tab Lawson \tab \tab Patricia
\par 04\tab \tab Akins\tab \tab \tab Jane
\par 05\tab \tab Fowler\tab \tab Sam
\par 
\par }\pard\plain \s4\qj\keepn\nowidctlpar\outlinelevel3\adjustright \b\f1 {Customer
\par }\pard\plain \qj\nowidctlpar\adjustright \fs20 {\f1\fs24 
\par Cust_no\tab Cust_name\tab \tab City
\par }\pard\plain \s1\qj\keepn\nowidctlpar\outlinelevel0\adjustright \f1 {11\tab \tab Ward\tab \tab \tab New York
\par }\pard\plain \qj\nowidctlpar\adjustright \fs20 {\f1\fs24 12\tab \tab Clark\tab \tab \tab Paris
\par 13\tab \tab Blake\tab \tab \tab Dallas
\par 14\tab \tab Sharma\tab \tab Delhi
\par 15\tab \tab Black\tab \tab \tab Melbourne\tab 
\par }{\b\f1\fs24 
\par Trans
\par }{\f1\fs24 
\par Supp_no\tab Cust_no\tab Item
\par 01\tab \tab 11\tab \tab Bed
\par 02\tab \tab 13\tab \tab Table
\par 15\tab \tab 12\tab \tab Chair
\par 21\tab \tab 15\tab \tab Mirror
\par 50\tab \tab 11\tab \tab Desk
\par 01\tab \tab 13\tab \tab Cabinet
\par 02\tab \tab 15\tab \tab Coffee Table
\par 
\par }{\b\f1\fs28 Keys
\par }{\f1\fs24 
\par First, let's discuss the concept of keys.
\par  A }{\b\f1\fs24 Primary Key}{\f1\fs24  is a column or set of columns that uniquely idenifies the rest of the data in any given row. 
\par e.g., in the Supplier table, the Supp_no column uniquely identifies that row.
\par This means two things:
\par 1) No two rows can have the same Supp_no and, 
\par 2) Even if two owners have the same first and last names, the Supp_no\~
column ensures that the two owners will not be confused with each other, because the unique Supp_no column will be used throughout the database to track the owners, rather than the names.
\par 
\par A }{\b\f1\fs24 Foreign Key }{\f1\fs24 is a column in a table where that column is a primary key of another table, which means that any data in a foreign key column must have corresponding data in the other table where that column is the primary key.

\par In DBMS-speak, this correspondence is known as }{\b\f1\fs24 Referential Integrity}{\f1\fs24 .
\par E.g. in the Trans table, both the Supp_no and Cust_no are foreign keys.
\par 
\par 
\par }{\b\f1\fs28 1.7.1\tab \tab Performing a Join}{\b\f1\fs24 
\par }{\f1\fs24 
\par The purpose of these keys is so that data can be related across tables, without having to repeat data in every table--this is the power of }{\f1\fs24\ul relational databases}{\f1\fs24 
. E.g., you can find the names of those who bought a chair without having to list the full name of the buyer in the Item table.
\par you can get the name by relating those who bought a chair with the names in the Supplier table through the use of the Supp_no, which relates the data in the two tables. 
\par To find the names of those who bought a chair, use the following query:
\par 
\par SELECT cust_name, item
\par FROM Customer, Trans
\par WHERE Trans.cust_no = Customer.cust_no AND  item = 'Chair';
\par 
\par Note the following about this query
\par {\pntext\pard\plain\f1 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\f1\fs24 
Notice that both tables involved in the relation are listed in the FROM clause of the statement .
\par {\pntext\pard\plain\f1 \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\f1\fs24 In the WHERE clause, firs
t notice that the ITEM = 'Chair' part restricts the listing to those who have bought a chair. 
\par {\pntext\pard\plain\f1 \hich\af1\dbch\af0\loch\f1 3.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\f1\fs24 
Secondly, notice how the NO columns are related from one table to the next by use of the Trans.cust_no = Customer.cust_no clause.
\par {\pntext\pard\plain\f1 \hich\af1\dbch\af0\loch\f1 4.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\f1\fs24 Only where NO's match a
cross tables and the item purchased is a chair (because of the AND), will the names from the Customer table be listed. 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 Because the joining condition used an equal sign, this join is called an '}{\b\f1\fs24 EQUIJOIN'}{\f1\fs24 . 
\par 
\par Dot notation refers to prefixing the table names to column names, to avoid ambiguity, as such:
\par 
\par }\pard \nowidctlpar\adjustright {\f1\fs24 SELECT supplier.sup_no, supplier.lname, supplier.fname
\par FROM supplier, Item
\par WHERE Item.supp_no = supplier.supp_no AND Item.item = 'Chair';
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }{\b\f1\fs24 
\par 
\par }{\b\f1\fs28 1.8\tab \tab Aliases}{\b\f1\fs24  
\par 
\par }{\f1\fs24 
Suppose we want to compare the values in two rows, e.g. the salaries of 2 people and we know the names of these people. Then we can scroll the same table i.e. emp table. For this we will need 2 different names for the same table which are called as aliase
s.
\par 
\par e.g. The above requirement  can be satisfied by the following query :
\par 
\par SELECT a.ename, a.sal, b.ename, b.sal 
\par FROM emp a, emp b
\par WHERE a.ename = 'BLAKE' AND b.ename = 'SMITH';
\par 
\par In this case 'a' and 'b' are the alias names given to the emp table.
\par }{\b\f1\fs24 
\par 
\par }{\b\f1\fs28 1.9\tab \tab Subqueries}{\b\f1\fs24  
\par 
\par }{\f1\fs24 Subquery is a form an  SQL statement that appears inside another SQL statement.  It is also termed as a 'Nested Query'. 
\par Suppose we want  the name of the person earning the maximum salary, we can first find out the maximum salary and then the name of the person who is earning it.
\par e.g.
\par SELECT ename, sal
\par FROM emp
\par WHERE sal = (select max(sal) FROM emp);
\par 
\par In this case the subquery will return the maximum salary value and the main query will use that value to test the condition in where clause.
\par 
\par If the user wants the information from a table dependant on the information from the another table, then also we can use subquery as follows :
\par 
\par Suppose we want the names of the people who are working in New york then:
\par 
\par SELECT ename 
\par FROM emp
\par WHERE deptno = (SELECT deptno FROM dept WHERE dname = 'NEW YORK');
\par 
\par We can also use relational operators with subqueries.
\par 
\par Suppose we want to find the list of the people who are earning salary greater than the clerk who is earning hightest salary then 
\par 
\par 
\par SELECT ename, sal 
\par FROM emp
\par WHERE sal > (SELECT max(sal) FROM emp
\par \tab \tab  WHERE job = 'CLERK');
\par 
\par 
\par }{\b\f1\fs28 1.10\tab \tab EXISTS & ALL
\par }{\f1\fs24 
\par EXISTS uses a subquery as a condition where, the condition is true if the subquery returns any rows and False if the subquery does not return any rows; this is a nonintuitive feature with few unique uses.
\par 
\par  However, if a prospective customer wanted to see the list of Owners only if the shop dealt in Chairs, try:
\par 
\par SELECT fname, lname
\par FROM supplier
\par WHERE exists  (SELECT *
\par \tab \tab  FROM Item
\par \tab \tab  WHERE item = 'Chair');
\par 
\par If there are any Chairs in the Item column, the subquery would return a row or rows, making the EXISTS clause true, causing SQL to list the Antique Owners. If there had been no Chairs, no rows would have been returned by the outside query.
\par 
\par ALL is another unusual feature, as ALL queries can usually be done with different and possibly simpler methods; let's take a look at an example query:
\par 
\par SELECT cust_no, item
\par FROM Item
\par WHERE price >= ALL (SELECT price
\par    \tab        \tab         FROM Item);
\par 
\par 
\par This will return the largest priced item (or more than one item if there is a tie) and its buyer. The subquery returns a list of all Prices in the Item table and the outer query goes through each row of the Item table and if its Price is greater than or e
qual to every (or ALL) Prices in the list, it is listed, giving the highest priced Item. The reason ">=" must be used is that the highest priced item will be equal to the highest price on the list, because this Item is in the Price list.
\par \page 
\par }\pard \nowidctlpar\box\brdrs\brdrw15\brsp20 \adjustright {\b\caps\f1\fs24 CHAPTER II\tab         \tab \tab \tab \tab                 WORKING WITH TABLES}{\b\caps\f1\fs28 
\par }\pard \qr\nowidctlpar\adjustright {\f1\fs24 
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs28 2.1\tab \tab Creating New Tables}{\f1\fs28 
\par }{\f1\fs24 
\par All tables within a database must be created at some point in time...
\par 
\par Create table table_name
\par (col1 datatype(width) [constraint constraint_name constraint] default default_val,
\par col2 datatype(width) [constraint constraint_name constraint] default default_val,
\par column3\'85\'85\'85\'85);
\par 
\par }{\b\f1\fs24 Datatypes}{\f1\fs24  }{\b\f1\fs24 :
\par }{\f1\fs24 
\par Some common generic data types are:
\par 
\par }\pard \qj\fi-1800\li1980\nowidctlpar\tx1980\adjustright {\f1\fs24 \bullet  }{\b\f1\fs24 Char(x)}{\f1\fs24  -\tab A column of characters, where x is a number designating the maximum number of characters allowed (maximum length) in the column. 
\par \bullet  }{\b\f1\fs24 Integer }{\f1\fs24 - \tab A column of whole numbers, positive or negative. 
\par \bullet  }{\b\f1\fs24 Decimal(x, y) }{\f1\fs24 -A column of decimal numbers, where x is the maximum length in digits of the decimal numbers in this column and y is the maximum number of digits allowed
 after the decimal point. The maximum (4,2) number would be 99.99. 
\par \bullet  }{\b\f1\fs24 Date }{\f1\fs24 - \tab A date column in a DBMS-specific format. 
\par \bullet  }{\b\f1\fs24 Logical }{\f1\fs24 - \tab A column that can hold only two values: TRUE\~or FALSE. 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par 
\par Constraints include the following possibilities (automatically enforced by the DBMS; failure causes an error to be generated):
\par 
\par }\pard \qj\fi-2700\li2700\nowidctlpar\adjustright {\b\f1\fs24 1. NULL or NOT NULL\tab }{\f1\fs24 Where}{\b\f1\fs24  }{\f1\fs24 to accept null values or not}{\b\f1\fs24  }{\f1\fs24  
\par }{\b\f1\fs24 2. UNIQUE \tab }{\f1\fs24 enforces that no two rows will have the same value for this column 
\par }{\b\f1\fs24 3. PRIMARY KEY \tab }{\f1\fs24 tells the database that this column is the primary key column. This column will always contain unique values and will be not null column. (only used if the key is a one column key, otherwise a PRIMARY\~
KEY (column, column, ...) statement appears after the last column definition. 
\par }{\b\f1\fs24 4. CHECK \tab }{\f1\fs24 allows a condition to be checked for when data in that column is updated or inserted; 
\par \tab e.g., CHECK (PRICE > 0) causes the system to check that the Price column is greater than zero before accepting the value... sometimes implemented as the CONSTRAINT statement.
\par }{\b\f1\fs24 5. DEFAULT \tab }{\f1\fs24 inserts the default value into the database if a row is inserted without that column's data being inserted; e.g., BENEFITS INTEGER DEFAULT = 10000 
\par }{\b\f1\fs24 6. FOREIGN KEY}{\f1\fs24  \tab works the same as Primary Key, but is followed by: REFERENCES <TABLE NAME> (<COLUMN NAME>), which refers to the referential primary key. 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par let's see how we would create the Orders table:
\par 
\par CREATE TABLE orders
\par (supp_no INTEGER NOT NULL,
\par itemname CHAR(40) NOT NULL);
\par 
\par This s
tatement gives the table name and tells the DBMS about each column in the table. Please note that this statement uses generic data types and that the data types might be different, depending on what DBMS you are using. As usual, check local listings. One 
other note, the NOT\~NULL means that the column must have a value in each row. If NULL was used, that column may be left empty in a given row.
\par 
\par We can create a new table based on the existing table.
\par CREATE table new_table_name (col1, col2, col3)  as
\par (SELECT field1, field2, field3 FROM old_table_name [where condition] );
\par 
\par then For new table column names are optional if you want to keep same field names
\par 
\par }{\b\f1\fs24 2.2\tab \tab Altering Tables}{\f1\fs24 
\par 
\par ALTER TABLE table_name
\par [ADD (col_name col_datatype col_constraint)] |
\par [DROP CONSTRAINT constraint_name] |
\par [MODIFY existing_col_name new_col_datatype new_constraint new default];
\par 
\par Let's add a column to the Item table to allow the entry of the price of a given Item:
\par 
\par alter table Item add (price decimal (8,2) null);
\par 
\par The data for this new column can be updated or inserted as shown later.
\par Columns cannot be removed from the existing table using this command.
\par }{\b\caps\f1\fs24 
\par 2.3\tab \tab Adding Data
\par }{\f1\fs24 
\par To insert rows into a table, do the following:
\par }{\caps\f1\fs24 
\par INSERT INTO}{\f1\fs24  table_name VALUES (val1, val2, val3, \'85..);
\par 
\par This inserts the data into the table, as a new row, column-by-column, in the pre-defined order.}{\caps\f1\fs24 
\par }{\f1\fs24 e.g. -
\par INSERT INTO Item VALUES (21, 01, 'Ottoman', 200.00);
\par 
\par But if you want to change the order then :
\par }{\caps\f1\fs24 
\par INSERT INTO}{\f1\fs24  table_name (col1, col2, col3, \'85..)
\par VALUES (val1, val2, val3, \'85..);
\par 
\par So, let's change the order and leave Price blank:
\par 
\par INSERT INTO Item (cust_no, cust_no, item)
\par VALUES (01, 21, 'Ottoman');
\par 
\par }{\b\caps\f1\fs24 2.4\tab \tab Deleting Data}{\caps\f1\fs24 
\par }{\f1\fs24 
\par Delete is used to delete one or multiple rows at a time.
\par DELETE FROM table_name
\par [where condition];
\par Remember, if we don't give where clause i.e. condition, then all the rows of that table will be deleted.
\par 
\par Let's delete this new row back out of the database:
\par 
\par DELETE FROM Item
\par WHERE item = 'Ottoman';
\par 
\par But if there is another row that contains 'Ottoman', that row also will be deleted. Let's delete all rows (one, in this case) that contain the specific data we added before:
\par 
\par DELETE FROM Item
\par WHERE item = 'Ottoman' AND cust_no = 01 AND cust_no = 21;
\par 
\par }{\b\caps\f1\fs24 2.5\tab \tab Updating Data
\par }{\f1\fs24 
\par UPDATE table_name
\par SET col_name1 = value1 [, col_name2 = value2,\'85]
\par [where condition] ;
\par 
\par Let's update a Price into a row that doesn't have a price listed yet:
\par 
\par UPDATE Item SET price = 500.00 WHERE item = 'Chair';
\par 
\par This sets all Chair's Prices to 500.00. As shown above, more WHERE conditionals, using AND, must be used to limit the updating to more specific rows. Also, additional columns may be set by separating equal statements with commas.
\par \page 
\par }\pard \nowidctlpar\box\brdrs\brdrw15\brsp20 \adjustright {\b\caps\f1\fs24 CHAPTER III \tab         \tab \tab INDEX, VIEWS AND OTHER FEATURES
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }{\b\caps\f1\fs24 3.1\tab \tab Indexes
\par }{\f1\fs24 
\par Indexes allow a DBMS to access data quicker. The system creates this internal data structure (the index) which causes selection of rows, when the selection is based on indexed columns, to occur faster. This ind
ex tells the DBMS where a certain row is in the table given an indexed-column value, much like a book index tells you what page a given word appears. 
\par 
\par CREATE [UNIQUE] INDEX index_name
\par ON table_name(col_name1 [asc|dessc], col_name2 \'85..);
\par 
\par Let's create an index for the Supp_no in the Supplier column:
\par 
\par CREATE INDEX oid_idx ON supplier (supp_no);
\par 
\par Now on the names:
\par 
\par }\pard \nowidctlpar\adjustright {\f1\fs24 CREATE INDEX name_idx ON supplier (lname, fname);
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par To get rid of an index, drop it:
\par 
\par DROP INDEX oid_idx;
\par 
\par By the way, you can also "drop"\~a table, as well (careful!--that means that your table is deleted). In the second example, the index is kept on the two columns, aggregated together--strange behavior might occur in this situation.
\par 
\par Some DBMS's do not enforce primary keys; in other words, the uniqueness of a column is not enforced automatically. What that means is, if, e.g., I tried to insert another row into the Supplier table with an Supp_no of 02, some systems will allow me to do 
t
hat, even though, we do not, as that column is supposed to be unique to that table (every row value is supposed to be different). One way to get around that is to create a unique index on the column that we want to be a primary key, to force the system to
 enforce prohibition of duplicates:
\par 
\par CREATE UNIQUE index oid_idx ON supplier (supp_no);
\par 
\par 
\par }{\b\caps\f1\fs24 
\par 3.2\tab \tab Views
\par }{\f1\fs24 
\par In SQL, you might  have access to create views for yourself. What a view does is to allow you to assign the results of a query to a new, personal table, t
hat you can use in other queries, where this new table is given the view name in your FROM clause. When you access a view, the query that is defined in your view creation statement is performed (generally) and the results of that query look just like anot
her table in the query that you wrote invoking the view. E.g., to create a view:
\par 
\par CREATE VIEW antview AS 
\par \tab SELECT\~itemname\~FROM orders;
\par 
\par Now, write a query using this view as a table, where the table is just a listing of all Items Desired from the Orders table:
\par 
\par SELECT cust_no
\par FROM Item, antview
\par WHERE itemname = item;
\par 
\par This query shows all Cust_no's from the Item table where the Item in that table happens to appear in the Antview view, which is just all of the Items Desired in the Orders table. The listing i
s generated by going through the Antique Items one-by-one until there's a match with the Antview view. Views can be used to restrict database access, as well as, in this case, simplify a complex query.
\par 
\par }{\b\f1\fs24 
\par 3.3\tab \tab SET OPERATORS
\par }{\f1\fs24 
\par }{\b\f1\fs24 UNION }{\f1\fs24 
\par There are occasions where you might want to see the results of multiple queries together, combining their output; use UNION. To merge the output of the following two queries, displaying the ID's of all Buyers, plus all those who have an Order placed:

\par 
\par SELECT cust_no
\par FROM supplier
\par UNION
\par SELECT supp_no
\par FROM orders;
\par 
\par Notice that SQL requires that the Select list (of columns) must match, column-by-column, in data type. In this case Cust_no and Supp_no are of the same data type (integer). Also notice that SQL does automatic duplicate el
imination when using UNION (as if they were two "sets"); in single queries, you have to use DISTINCT.
\par 
\par The outer join is used when a join query is "united" with the rows not included in the join and are especially useful if constant text "flags" are included. First, look at the query:
\par 
\par SELECT supp_no, 'is in both Orders & Item'
\par FROM orders, Item
\par WHERE supp_no = cust_no
\par UNION
\par SELECT cust_no, 'is in Item only'
\par FROM Item
\par WHERE cust_no not in (select supp_no
\par \tab \tab \tab   from orders);
\par 
\par The first query does a join to li
st any owners who are in both tables and putting a tag line after the ID repeating the quote. The UNION merges this list with the next list. The second list is generated by first listing those ID's not in the Orders table, thus generating a list of ID's e
x
cluded from the join query. Then, each row in the Item table is scanned and if the Cust_no is not in this exclusion list, it is listed with its quoted tag. There might be an easier way to make this list, but it's difficult to generate the informational qu
oted strings of text.
\par 
\par This concept is useful in situations where a primary key is related to a foreign key, but the foreign key value for some primary keys is NULL. E.g., in one table, the primary key is a salesperson and in another table is customers, wit
h their salesperson listed in the same row. However, if a salesperson has no customers, that person's name won't appear in the customer table. 
\par The outer join is used if the listing of all salespersons is to be printed, listed with their customers, whether
 the salesperson has a customer or not--that is, no customer is printed (a logical NULL value) if the salesperson has no customers, but is in the salespersons table. Otherwise, the salesperson will be listed with each customer.
\par 
\par INTERSECT\~and MINUS are like the UNION\~statement, except that INTERSECT produces rows that appear in both queries and MINUS produces rows that result from the first query, but not the second. 
\par 
\par 
\par }{\b\f1\fs24 3.4\tab \tab Report Generation Features:
\par }{\f1\fs24 
\par The COMPUTE\~clause is placed at the end of a query to place the result of an aggregate function at the end of a listing, like 
\par 
\par COMPUTE SUM (price); 
\par 
\par Another option is to use break logic: define a break to divide the query results into groups based on a column, like 
\par 
\par BREAK ON cust_no
\par 
\par Then, to produce a result after the listing of a group, use 
\par 
\par COMPUTE SUM OF price on cust_no
\par 
\par If, e.g.,    you used all three of these clauses (BREAK first, COMPUTE on break second, COMPUTE overall sum third), you would get a report that grouped items by 
their Cust_no, listing the sum of Prices after each group of a Cust_no's items, then, after all groups are listed, the sum of all Prices is listed, all with SQL-generated headers and lines. 
\par }\pard \nowidctlpar\box\brdrs\brdrw15\brsp20 \adjustright {\b\caps\f1\fs24 CHAPTER IV \tab    \tab \tab \tab \tab \tab \tab       FUNCTIONS}{\b\caps\f1\fs28 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }{\b\f1\fs24 4.1\tab \tab Aggregate Functions
\par }{\f1\fs24 
\par Let us discuss five important aggregate functions: SUM, AVG, MAX, MIN and COUNT. They are called aggregate functions because they summarize the results of a query, rather than listing all of the rows. 
\par 
\par {\pntext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360\tx1530{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec\pnb1\pnstart1\pnindent360\pnhang{\pntxta .}}\ls11\adjustright {\b\f1\fs24 SUM( )\tab }{
\f1\fs24 gives the total of all the rows, satisfying any conditions, of the \tab   \tab given column, where the given column is numeric. 
\par {\pntext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360\tx1530{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec\pnb1\pnstart1\pnindent360\pnhang{\pntxta .}}\ls11\adjustright {\b\f1\fs24 AVG( )}{\f1\fs24  
\tab gives the average of the given column. 
\par {\pntext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 3.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360\tx1530{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec\pnb1\pnstart1\pnindent360\pnhang{\pntxta .}}\ls11\adjustright {\b\f1\fs24 MAX( )}{\f1\fs24  
\tab gives the largest figure in the given column. 
\par {\pntext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 4.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360\tx1530{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec\pnb1\pnstart1\pnindent360\pnhang{\pntxta .}}\ls11\adjustright {\b\f1\fs24 MIN( )}{\f1\fs24  
\tab gives the smallest figure in the given column. 
\par {\pntext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 5.\tab}}\pard \qj\fi-360\li360\nowidctlpar\jclisttab\tx360\tx1530{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec\pnb1\pnstart1\pnindent360\pnhang{\pntxta .}}\ls11\adjustright {\b\f1\fs24 COUNT(*)}{\f1\fs24 
 gives the number of rows satisfying the conditions. 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par Looking at the tables at the top of the document, let's look at three examples:
\par 
\par SELECT SUM(salary), AVG(salary)
\par FROM empstat;
\par 
\par This query shows the total of all salaries in the table and the average salary of all of the entries in the table.
\par 
\par SELECT MIN(benefits)
\par FROM empstat
\par WHERE position = 'Manager';
\par 
\par This query gives the smallest figure of the Benefits column, of the employees who are Managers.
\par 
\par SELECT count(*)
\par FROM empstat
\par WHERE position = 'Staff';
\par 
\par This query tells you how many employees have Staff status (3).
\par }{\b\f1\fs24 
\par {\listtext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 4.2\tab}}\pard \qj\fi-1440\li1440\nowidctlpar\jclisttab\tx1440\ls5\ilvl1\adjustright {\b\f1\fs24 Mathematical Functions
\par }\pard \qj\nowidctlpar\adjustright {\b\f1\fs24 
\par }\pard \qj\fi-2160\li2160\nowidctlpar\adjustright {\b\f1\fs24 ABS(X)}{\f1\fs24 \tab Absolute value-converts negative numbers to positive, or leaves positive numbers alone
\par }\pard \qj\fi-2160\li2160\nowidctlpar\tx2160\adjustright {\b\f1\fs24 CEIL(X)}{\f1\fs24 \tab X is a decimal value that will be rounded up.
\par }{\b\f1\fs24 FLOOR(X)\tab }{\f1\fs24 X is a decimal value that will be rounded down. 
\par }{\b\f1\fs24 GREATEST(X,Y) }{\f1\fs24 \tab Returns the largest of the two values. 
\par }{\b\f1\fs24 LEAST(X,Y) \tab }{\f1\fs24 Returns the smallest of the two values. 
\par }{\b\f1\fs24 MOD(X,Y) \tab }{\f1\fs24 Returns the remainder of X / Y. 
\par }{\b\f1\fs24 POWER(X,Y) \tab }{\f1\fs24 Returns X to the power of Y. 
\par }{\b\f1\fs24 ROUND(X,Y) \tab }{\f1\fs24 Rounds X to Y decimal places. If Y is omitted, X is rounded to the nearest integer. 
\par }{\b\f1\fs24 SIGN(X) \tab }{\f1\fs24 Returns a minus if X < 0, else a plus. 
\par }{\b\f1\fs24 SQRT(X) \tab }{\f1\fs24 Returns the square root of X.
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }{\b\f1\fs24 4.3\tab \tab Character Functions}{\f1\fs24 
\par 
\par }\pard \qj\nowidctlpar\tx3150\adjustright {\b\f1\fs24 LEFT(<string>,X)}{\f1\fs24 \tab Returns the leftmost X characters of the string.
\par }{\b\f1\fs24 RIGHT(<string>,X)}{\f1\fs24 \tab Returns the rightmost X characters of the string.
\par }{\b\f1\fs24 UPPER(<string>)}{\f1\fs24 \tab Converts the string to all uppercase letters.
\par }{\b\f1\fs24 LOWER(<string>)}{\f1\fs24 \tab Converts the string to all lowercase letters.
\par }{\b\f1\fs24 INITCAP(<string>)}{\f1\fs24 \tab Converts the string to initial caps.
\par }{\b\f1\fs24 LENGTH(<string>)}{\f1\fs24 \tab Returns the number of characters in the string.
\par }\pard \qj\fi-3150\li3150\nowidctlpar\adjustright {\b\f1\fs24 <String>||<string>}{\f1\fs24 \tab Combines the two strings of text into one, concatenated string, where the first string is immediately followed by the second.
\par }{\b\f1\fs24 LPAD(<string>,X,'*')\tab }{\f1\fs24 Pads the string on the left with the * (or whatever character is inside the quotes), to make the string X characters long.
\par }{\b\f1\fs24 RPAD(<string>,X,'*')\tab }{\f1\fs24 Pads the string on the right with the * (or whatever character is inside the quotes), to make the string X characters long.
\par }{\b\f1\fs24 SUBSTR(<string>,X,Y)\tab }{\f1\fs24 Extracts Y letters from the string beginning at position X.
\par }{\b\f1\fs24 NVL(<column>,<value>)\tab }{\f1\fs24 The Null value function will substitute <value> for any NULLs for in the <column> If the current value of <column> is not NULL, NVL has no effect.
\par }\pard \qj\fi-3150\li3150\nowidctlpar\tx3150\adjustright {\b\f1\fs24 INSTR(char1, char2[,n[,m]])}{\f1\fs24 \tab 
Searches char1 beginning with its nth character for the mth occurance of char2 and returns the position of the character  in char1 that is the first character of this occurance.
\par }{\b\f1\fs24 LTRIM(char[,set])}{\f1\fs24 \tab This function removes the characters from the left of char, with initial characterss removed up to the first character not in set.
\par }{\b\f1\fs24 SOUNDEX(char)}{\f1\fs24 \tab The function returns a character string containing the phonetic representation of char.  This function allows you to compare words that are spelled differently, but sound alike in English.
\par }{\b\f1\fs24 DECODE(expr, search, result[,search,result]...[,default])}{\f1\fs24 
\par \tab The function compares expr to each search value one by one.  If expr is equal to a search, Oracle returns the corresponding result.  If no match is found, Oracle returns default, or, if default is omitted, returns null.
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par {\listtext\pard\plain\b\f1 \hich\af1\dbch\af0\loch\f1 4.3\tab}}\pard \qj\fi-1440\li1440\nowidctlpar\jclisttab\tx1440\ls5\ilvl1\adjustright {\b\f1\fs24 Date Functions 
\par }\pard \qj\nowidctlpar\adjustright {\f1\fs24 
\par }\pard \qj\fi-3150\li3150\nowidctlpar\tx3150\adjustright {\b\f1\fs24 TO_DATE(char [,fmt])}{\f1\fs24 \tab Converts char  of CHAR or VARCHAR2 datatype to a value  of DATE datatype.If you omit fmt, char must be in the default date format.
\par }{\b\f1\fs24 TO_CHAR(d[,fmt])}{\f1\fs24 \tab Converts d of DATE datatype to a value of VARCHAR2 datatype in the format specified by the date format fmt. If you omit fmt, d is converted to a VARCHAR2 value in the default date format.\tab 
\par }{\b\f1\fs24 LAST_DAY(d)}{\f1\fs24 \tab Returns the date of the last day of the month that contains d.
\par }{\b\f1\fs24 MONTHS_BETWEEN(d1,d2)}{\f1\fs24 \tab 
Returns number of months between dates d1 and d2. If d1 is later than d2, result is positive else negative.  If d1 and d2 are either the same days of the months or both last days of months, the result is always integer else Or
acle calculates the fractional portion of the result based on a 31-day month.
\par }{\b\f1\fs24 NEW_TIME(d,z1,z2)}{\f1\fs24 \tab Returns the date and time in time zone z2 when date and time in time zone z1 are d. The  arguments z1 and z2 can by text strings like
\par \tab \lquote AST\rquote  or \lquote ADT\rquote  Atlantic Standard or Daylight Time
\par \tab \lquote BST\rquote  or \lquote BDT\rquote  Bering Standard or Daylight Time
\par }{\b\f1\fs24 NEXT_DAY(d, char)}{\f1\fs24 \tab Returns the date of the first weekday named by char that is later than the date d.  The argument char must be a day of the week.  The return value has the same hour
s, minutes, seconds compunents as the argument d.
\par }{\b\f1\fs24 ADD_MONTHS(d,n)}{\f1\fs24 \tab Returns the date d plus n months.  The argument n can be any integer.
\par 
\par }}